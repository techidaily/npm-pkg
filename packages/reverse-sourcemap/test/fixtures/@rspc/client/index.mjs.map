{"version":3,"sources":["../src/client.ts","../src/transport.ts","../src/react.tsx","../src/error.ts"],"sourcesContent":["import { Transport } from \"./transport\";\n\nexport type OperationType =\n  | \"query\"\n  | \"mutation\"\n  | \"subscriptionAdd\"\n  | \"subscriptionRemove\";\n\nexport type OperationKey = [string] | [string, /* args */ any];\n\nexport type OperationsDef = {\n  queries: { key: OperationKey; result: any };\n  mutations: { key: OperationKey; result: any };\n  subscriptions: { key: OperationKey; result: any };\n};\n\nexport interface ClientTransformer {\n  serialize(type: OperationType, key: OperationKey): OperationKey;\n  deserialize(type: OperationType, key: OperationKey, data: any): any;\n}\nexport interface ClientArgs {\n  transport: Transport;\n  transformer?: ClientTransformer;\n}\n\nexport function createClient<T extends OperationsDef>(\n  args: ClientArgs\n): Client<T> {\n  return new Client(args);\n}\n\nexport class Client<T extends OperationsDef> {\n  private transport: Transport;\n  private subscriptionMap = new Map<string, (data: any) => void>();\n\n  constructor(args: ClientArgs) {\n    this.transport = args.transport;\n    this.transport.transformer = args.transformer;\n    this.transport.clientSubscriptionCallback = (id, key, value) => {\n      const func = this.subscriptionMap?.get(id);\n      if (func !== undefined) func(value);\n    };\n    this.subscriptionMap = new Map();\n  }\n\n  async query<K extends T[\"queries\"][\"key\"]>(\n    key: K\n  ): Promise<Extract<T[\"queries\"], { key: K }>[\"result\"]> {\n    return await this.transport.doRequest(\"query\", key);\n  }\n\n  async mutation<K extends T[\"mutations\"][\"key\"][0]>(\n    key: [K, Extract<T[\"mutations\"], { key: [K, any] }>[\"key\"][1]]\n  ): Promise<Extract<T[\"mutations\"], { key: K }>[\"result\"]> {\n    return await this.transport.doRequest(\"mutation\", key);\n  }\n\n  // TODO: Redesign this, i'm sure it probably has race conditions but it functions for now\n  addSubscription<K extends T[\"subscriptions\"][\"key\"][0]>(\n    key: Extract<\n      T[\"subscriptions\"][\"key\"],\n      { key: [K, any] }\n    >[1] extends undefined\n      ? [K]\n      : [K, Extract<T[\"subscriptions\"][\"key\"], { key: [K, any] }>[1]],\n    options: {\n      onNext(msg: Extract<T[\"subscriptions\"], { key: [K, any] }>[\"result\"]);\n      onError?(err: never);\n    }\n  ): () => void {\n    let subscriptionId = undefined;\n    let unsubscribed = false;\n\n    const cleanup = () => {\n      this.subscriptionMap?.delete(subscriptionId);\n      if (subscriptionId) {\n        this.transport.doRequest(\"subscriptionRemove\", [subscriptionId]);\n      }\n    };\n\n    this.transport.doRequest(\"subscriptionAdd\", key).then((id) => {\n      subscriptionId = id;\n      if (unsubscribed) {\n        cleanup();\n      } else {\n        this.subscriptionMap?.set(subscriptionId, options.onNext);\n      }\n    });\n\n    return () => {\n      unsubscribed = true;\n      cleanup();\n    };\n  }\n}\n","import { listen, UnlistenFn } from \"@tauri-apps/api/event\";\nimport { appWindow } from \"@tauri-apps/api/window\";\nimport { ClientTransformer, OperationKey, OperationType, RSPCError } from \".\";\n\n// TODO: Make this file work off Typescript types which are exported from Rust to ensure internal type-safety!\n\nexport interface Transport {\n  transformer?: ClientTransformer;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  doRequest(operation: OperationType, key: OperationKey): Promise<any>;\n}\n\nexport class FetchTransport implements Transport {\n  private url: string;\n  transformer?: ClientTransformer;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n  }\n\n  async doRequest(operation: OperationType, key: OperationKey): Promise<any> {\n    if (operation === \"subscriptionAdd\" || operation === \"subscriptionRemove\") {\n      throw new Error(\n        `Subscribing to '${key[0]}' failed as the HTTP transport does not support subscriptions! Maybe try using the websocket transport?`\n      );\n    }\n\n    let method = \"GET\";\n    let body = undefined as any;\n    let headers = new Headers();\n\n    const params = new URLSearchParams();\n    key = this.transformer?.serialize(operation, key) || key;\n    if (operation === \"query\") {\n      if (key[1] !== undefined) {\n        params.append(\"input\", JSON.stringify(key[1]));\n      }\n    } else if (operation === \"mutation\") {\n      method = \"POST\";\n      body = JSON.stringify(key[1] || {});\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    const paramsStr = params.toString();\n    const resp = await fetch(\n      `${this.url}/${key[0]}${paramsStr.length > 0 ? `?${paramsStr}` : \"\"}`,\n      {\n        method,\n        body,\n        headers,\n      }\n    );\n\n    const respBody = (await resp.json())[0]; // TODO: Batching\n    const { type, result } = respBody;\n    if (type === \"error\") {\n      const { status_code, message } = respBody;\n      throw new RSPCError(status_code, message);\n    }\n    return this.transformer?.deserialize(operation, key, result) || result;\n  }\n}\n\nconst randomId = () => Math.random().toString(36).slice(2);\n\nconst timeouts = [1000, 2000, 5000, 10000]; // In milliseconds\n\nexport class WebsocketTransport implements Transport {\n  private url: string;\n  private ws: WebSocket;\n  private requestMap = new Map<string, (data: any) => void>();\n  transformer?: ClientTransformer;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  constructor(url: string) {\n    this.url = url;\n    this.ws = new WebSocket(url);\n    this.attachEventListeners();\n  }\n\n  attachEventListeners() {\n    this.ws.addEventListener(\"message\", (event) => {\n      const body = JSON.parse(event.data);\n      if (body.type === \"event\") {\n        const { id, key, result } = body;\n        this.clientSubscriptionCallback(id, key, result);\n      } else if (body.type === \"response\") {\n        const { id, result } = body;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.({ type: \"response\", result });\n          this.requestMap.delete(id);\n        }\n      } else if (body.type === \"error\") {\n        const { id, message, status_code } = body;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.({ type: \"error\", message, status_code });\n          this.requestMap.delete(id);\n        }\n      } else {\n        console.error(`Received event of unknown type '${body.type}'`);\n      }\n    });\n\n    this.ws.addEventListener(\"close\", (event) => {\n      this.reconnect();\n    });\n  }\n\n  async reconnect(timeoutIndex = 0) {\n    let timeout =\n      (timeouts[timeoutIndex] ?? timeouts[timeouts.length - 1]) +\n      (Math.floor(Math.random() * 5000 /* 5 Seconds */) + 1);\n\n    setTimeout(() => {\n      let ws = new WebSocket(this.url);\n      new Promise(function (resolve, reject) {\n        ws.addEventListener(\"open\", () => resolve(null));\n        ws.addEventListener(\"close\", reject);\n      })\n        .then(() => {\n          this.ws = ws;\n          this.attachEventListeners();\n        })\n        .catch((err) => this.reconnect(timeoutIndex++));\n    }, timeout);\n  }\n\n  async doRequest(operation: OperationType, key: OperationKey): Promise<any> {\n    if (this.ws.readyState == 0) {\n      let resolve: () => void;\n      const promise = new Promise((res) => {\n        resolve = () => res(undefined);\n      });\n      // @ts-ignore\n      this.ws.addEventListener(\"open\", resolve);\n      await promise;\n    }\n\n    const id = randomId();\n    let resolve: (data: any) => void;\n    const promise = new Promise((res) => {\n      resolve = res;\n    });\n\n    // @ts-ignore\n    this.requestMap.set(id, resolve);\n\n    this.ws.send(\n      JSON.stringify({\n        id,\n        operation,\n        key: this.transformer?.serialize(operation, key) || key,\n      })\n    );\n\n    const body = (await promise) as any;\n    if (body.type === \"error\") {\n      const { status_code, message } = body;\n      throw new RSPCError(status_code, message);\n    } else if (body.type === \"response\") {\n      return (\n        this.transformer?.deserialize(operation, key, body.result) ||\n        body.result\n      );\n    } else {\n      throw new Error(\n        `RSPC Websocket doRequest received invalid body type '${body?.type}'`\n      );\n    }\n  }\n}\n\nexport class TauriTransport implements Transport {\n  private requestMap = new Map<string, (data: any) => void>();\n  private listener?: Promise<UnlistenFn>;\n  transformer?: ClientTransformer;\n  clientSubscriptionCallback?: (id: string, key: string, value: any) => void;\n\n  constructor() {\n    this.listener = listen(\"plugin:rspc:transport:resp\", (event) => {\n      const body = event.payload as any;\n      if (body.type === \"event\") {\n        const { id, key, result } = body;\n        this.clientSubscriptionCallback(id, key, result);\n      } else if (body.type === \"response\") {\n        const { id, result } = body;\n        if (this.requestMap.has(id)) {\n            this.requestMap.get(id)?.({ type: \"response\", result });\n            this.requestMap.delete(id);\n        }\n      } else if (body.type === \"error\") {\n        const { id, message, status_code } = body;\n        if (this.requestMap.has(id)) {\n          this.requestMap.get(id)?.({ type: \"error\", message, status_code });\n          this.requestMap.delete(id);\n        }\n      } else {\n        console.error(`Received event of unknown method '${body.type}'`);\n      }\n    });\n  }\n\n  async doRequest(operation: OperationType, key: OperationKey): Promise<any> {\n    if (!this.listener) {\n      await this.listener;\n    }\n\n    const id = randomId();\n    let resolve: (data: any) => void;\n    const promise = new Promise((res) => {\n      resolve = res;\n    });\n\n    // @ts-ignore\n    this.requestMap.set(id, resolve);\n\n    await appWindow.emit(\"plugin:rspc:transport\", {\n      id,\n      operation,\n      key: this.transformer?.serialize(operation, key) || key,\n    });\n\n    const body = (await promise) as any;\n    if (body.type === \"error\") {\n      const { status_code, message } = body;\n      throw new RSPCError(status_code, message);\n    } else if (body.type === \"response\") {\n      return (\n        this.transformer?.deserialize(operation, key, body.result) ||\n        body.result\n      );\n    } else {\n      throw new Error(\n        `RSPC Tauri doRequest received invalid body type '${body?.type}'`\n      );\n    }\n  }\n}\n","import React, { ReactElement, useEffect } from \"react\";\nimport {\n  QueryClient,\n  useQuery as _useQuery,\n  useMutation as _useMutation,\n  UseQueryResult,\n  UseQueryOptions,\n  UseMutationResult,\n  UseMutationOptions,\n  QueryClientProvider,\n} from \"@tanstack/react-query\";\nimport { Client, OperationsDef } from \"./client\";\nimport { RSPCError } from \"./error\";\n\nexport type OperationKeyArgs<\n  Operations extends OperationsDef,\n  Type extends keyof OperationsDef,\n  K extends Operations[Type][\"key\"][0]\n> = Extract<\n  Operations[Type],\n  { key: [K] | [K, any] }\n>[\"key\"][1] extends undefined\n  ? [K]\n  : [K, Extract<Operations[Type], { key: [K, any] }>[\"key\"][1]];\n\nexport type OperationKeyResult<\n  Operations extends OperationsDef,\n  Type extends keyof OperationsDef,\n  K extends Operations[Type][\"key\"][0]\n> = Extract<\n  Operations[Type],\n  { key: [K] | [K, any] }\n>[\"key\"][1] extends undefined\n  ? [K]\n  : [K, Extract<Operations[Type], { key: [K, any] }>[\"key\"][1]];\n\nexport type Demo<\n  Operations extends OperationsDef,\n  Type extends keyof OperationsDef,\n  K\n> = Extract<Operations[Type], { key: [K] | [K, any] }>;\n\ninterface Context<T extends OperationsDef> {\n  client: Client<T>;\n  queryClient: QueryClient;\n}\n\nexport function createReactQueryHooks<T extends OperationsDef>() {\n  const Context = React.createContext<Context<T>>(undefined!);\n  const ReactQueryContext = React.createContext<QueryClient>(undefined!);\n\n  function useContext() {\n    return React.useContext(Context);\n  }\n\n  function useQuery<K extends T[\"queries\"][\"key\"][0]>(\n    key: Demo<T, \"queries\", K>[\"key\"],\n    options?: UseQueryOptions<Demo<T, \"queries\", K>[\"result\"], RSPCError>\n  ): UseQueryResult<Demo<T, \"queries\", K>[\"result\"], RSPCError> {\n    const ctx = useContext();\n    return _useQuery(key, async () => ctx.client.query(key), {\n      ...options,\n      context: ReactQueryContext,\n    });\n  }\n\n  function useMutation<K extends T[\"mutations\"][\"key\"]>(\n    key: K[0],\n    options?: UseMutationOptions<\n      Extract<T[\"mutations\"], { key: K }>[\"result\"],\n      RSPCError,\n      K[1]\n    >\n  ): UseMutationResult<\n    Extract<T[\"mutations\"], { key: K }>[\"result\"],\n    RSPCError,\n    K[1]\n  > {\n    const ctx = useContext();\n    return _useMutation(async (data) => ctx.client.mutation([key, data]), {\n      ...options,\n      context: ReactQueryContext,\n    });\n  }\n\n  type SubscriptionKey = T[\"subscriptions\"][\"key\"][0];\n  type SubscriptionArg<K extends string> = Extract<\n    T[\"subscriptions\"],\n    { key: [K] | [K, any] }\n  >[\"key\"][1];\n  type SubscriptionResult<K extends string> = Extract<\n    T[\"subscriptions\"],\n    { key: [K] | [K, any] }\n  >[\"result\"];\n\n  function useSubscription<K extends SubscriptionKey>(\n    key: SubscriptionArg<K> extends undefined ? [K] : [K, SubscriptionArg<K>],\n    options?: {\n      onNext(msg: SubscriptionResult<K>);\n      onError?(err: RSPCError);\n    }\n  ) {\n    const ctx = useContext();\n\n    useEffect(() => {\n      const unsub = ctx.client.addSubscription(key, options);\n      return () => unsub();\n    }, []);\n  }\n\n  return {\n    Provider: ({\n      children,\n      client,\n      queryClient,\n    }: {\n      children: ReactElement;\n      client: Client<T>;\n      queryClient: QueryClient;\n    }) => (\n      <Context.Provider\n        value={{\n          client,\n          queryClient,\n        }}\n      >\n        <ReactQueryContext.Provider value={queryClient}>\n          <QueryClientProvider client={queryClient}>\n            {children}\n          </QueryClientProvider>\n        </ReactQueryContext.Provider>\n      </Context.Provider>\n    ),\n    useContext: () => {\n      return React.useContext(Context);\n    },\n    useQuery,\n    useMutation,\n    useSubscription,\n    // useDehydratedState,\n    // useInfiniteQuery,\n    ReactQueryContext,\n  };\n}\n","export class RSPCError {\n  code: number;\n  message: string;\n\n  constructor(code: number, message: string) {\n    this.code = code;\n    this.message = message;\n  }\n}\n"],"mappings":"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","names":["resolve","promise"]}